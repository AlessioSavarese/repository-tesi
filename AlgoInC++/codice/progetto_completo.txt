#include "OnePermutation.h"

OnePermutation::OnePermutation(size_t k, size_t m, size_t seed){
    this->k = k;
    this->m = m;
    funzHash = new HashFunction(m, seed);
   // std::cout << "DEBUG - OnePermutation: k=" << k << ", m=" << m << ", seed=" << seed << std::endl;
}

std::vector<uint64_t> OnePermutation::computeSignature(std::vector<uint64_t> s) {
    std::vector<uint64_t> signature(k, UINT64_MAX), sPerm;
    size_t numElemBin = m/k;
    
    for (size_t i = 0; i < s.size(); i++) {
        sPerm.push_back( funzHash->map(s[i]) );
        // std::cout << "DEBUG - Elemento: " << s[i] << ", HashValue: " << funzHash->map(s[i]) << std::endl;
    }
    
    for (size_t j = 0; j < k; j++){
        for (size_t i = 0; i < sPerm.size(); i++) {
            if ( sPerm[i] >= j*numElemBin && sPerm[i] < ((j+1)*numElemBin) ){
                if (sPerm[i]%numElemBin < signature[j]) signature[j] = sPerm[i]%numElemBin;
                /*std::cout << "DEBUG - Bin " << j 
                              << ": elemento=" << sPerm[i] 
                              << ", modValue=" << signature[j] 
                              << ", nuovo valore signature[" << j << "]=" << signature[j] << std::endl;*/
                              
            }
        }
    }
    return signature;
}
#include "KMinHash.h"

KMinHash::KMinHash(size_t k, size_t m, size_t seed) {
    this->k = k;
    this->m = m;
    vettoreFirme = std::vector<HashFunction*>(k, nullptr);
    for (size_t i = 0; i < k; ++i) {
        vettoreFirme[i] = new HashFunction(m, seed + i); // Semi diversi per ogni funzione hash
    }
}

std::vector<uint64_t> KMinHash::computeSignature(std::vector<uint64_t> s) {
    std::vector<uint64_t> signature(k, UINT64_MAX);
    size_t lung = s.size();
    for (size_t i = 0; i < k; i++) {
        for (size_t j = 0; j < lung; j++) {
            if (vettoreFirme[i]->map(s[j]) < signature[i]) {
                signature[i] = vettoreFirme[i]->map(s[j]);
            }
        }   
    }
    return signature;
}
#include "FSHashFunction.h"
#include <random>
#include <vector>

FSHashFunction::FSHashFunction(size_t seed, size_t m, size_t t){
    this->t = t;
    this->m = m;
    std::mt19937 gen(seed); // Generatore deterministico
    std::uniform_int_distribution<> distribA(1, m - 1);
    std::uniform_int_distribution<> distribB(0, m - 1);
    this->a = distribA(gen);
    this->b = distribB(gen);
    for (size_t i = 0; i < 2*t; i++){
        std::uniform_real_distribution<> distribI(i, i + 1); // [i,i+1)
        vettoreV.push_back( distribI(gen) );
    }
    //std::cout << "MyHash: a=" << a << ", b=" << b << ", m=" << m << std::endl;
}

std::pair<size_t, double> FSHashFunction::map(size_t x, size_t i)  {
    size_t b;
    double v = vettoreV[i];
    if (i<t){
        b = (static_cast<size_t>(a) * x + b) % t;
        return {b,v};
    }
    b = i-t;
    return {b,v};
}#include "FastSimilaritySketching.h"
#include <limits>
#include <vector>


FastSimilaritySketching::FastSimilaritySketching(size_t t, size_t m, size_t seed) {
    this->t = t;
    this->m = m;
    funzioniHash = new FSHashFunction(seed, m, t);
}

std::vector<double> FastSimilaritySketching::computeSignature(std::vector<uint64_t> s) {
    std::vector<double> signature(t, std::numeric_limits<double>::max());
    size_t lung = s.size();
    size_t c = 0;
    for (size_t i = 0; i < 2*t; i++) {
        for (size_t j = 0; j < lung; j++) {
            size_t b = (funzioniHash->map(s[j], i) ).first;
            double v = (funzioniHash->map(s[j], i) ).second;
            if (signature[b] == std::numeric_limits<double>::max() ) c++;
            if (v < signature[b]) signature[b] = v;
        }   
        if (c == t) return signature;
    }
    return signature;
}
#ifndef HASHFUNCTION_H  // Controlla se la macro non è già definita
#define HASHFUNCTION_H  // Definisci la macro per evitare inclusioni successive

#include <cstddef>
#include <iostream>
#include <vector>

class FSHashFunction {
private:
    size_t a;  ///< Coefficiente moltiplicativo
    size_t b;  ///< Coefficiente additivo
    size_t t;  ///< Modulo
    size_t m;
    std::vector<double> vettoreV;
public:
    /**
     * Costruttore.
     * @param m: Modulo per la funzione hash.
     * @param seed: Semina per il generatore casuale.
     */
    FSHashFunction(size_t seed, size_t m, size_t t);

    /**
     * Mappa un elemento `x` utilizzando la funzione hash.
     * @param x: Valore da mappare.
     * @return Valore hashato.
     */
    std::pair<size_t, double> map(size_t x, size_t i);
};

#endif // Fine della protezione contro l'inclusione multipla#include "HashFunction.h"
#include <random>

HashFunction::HashFunction(size_t seed, size_t m) {
    this->m = m;
    std::mt19937 gen(seed); // Generatore deterministico
    std::uniform_int_distribution<> distribA(1, m - 1);
    std::uniform_int_distribution<> distribB(0, m - 1);
    this->a = distribA(gen);
    this->b = distribB(gen);
    //std::cout << "MyHash: a=" << a << ", b=" << b << ", m=" << m << std::endl;
}
size_t HashFunction::map(size_t x) {
    return (static_cast<size_t>(a) * x + b) % m;
}#ifndef HASHFUNCTION_H  // Controlla se la macro non è già definita
#define HASHFUNCTION_H  // Definisci la macro per evitare inclusioni successive

#include <cstddef>
#include <iostream>

class HashFunction {
private:
    size_t a;  ///< Coefficiente moltiplicativo
    size_t b;  ///< Coefficiente additivo
    size_t m;  ///< Modulo
public:
    /**
     * Costruttore.
     * @param m: Modulo per la funzione hash.
     * @param seed: Semina per il generatore casuale.
     */
    HashFunction(size_t m, size_t seed);

    /**
     * Mappa un elemento `x` utilizzando la funzione hash.
     * @param x: Valore da mappare.
     * @return Valore hashato.
     */
    size_t map(size_t x);
};

#endif // Fine della protezione contro l'inclusione multipla#include <vector>
#include "FSHashFunction.h"

class FastSimilaritySketching {
private:
    size_t t;  ///< Numero di bin.
    size_t m;  ///< Modulo per le funzioni hash.
    FSHashFunction *funzioniHash; ///< Funzioni hash.

public:
    /**
     * Costruttore.
     * @param t: Numero di bin.
     * @param m: Modulo per le funzioni hash.
     * @param seed: Semina per il generatore casuale.
     */
    FastSimilaritySketching(size_t t, size_t m, size_t seed);

    /**
     * Calcola la firma di un vettore.
     * @param s: Vettore di input.
     * @return Firma come vettore di reali (double).
     */
    std::vector<double> computeSignature(std::vector<uint64_t> s);
};#include "HashFunction.h"
#include <vector>

class KMinHash {
private:
    size_t k;  ///< Numero di funzioni hash.
    size_t m;  ///< Modulo per le funzioni hash.
    std::vector<HashFunction*> vettoreFirme; ///< Funzioni hash.

public:
    /**
     * Costruttore.
     * @param k: Numero di funzioni hash.
     * @param m: Modulo per le funzioni hash.
     * @param seed: Semina per il generatore casuale.
     */
    KMinHash(size_t k, size_t m, size_t seed);

    /**
     * Calcola la firma k-minHash di un vettore.
     * @param s: Vettore di input.
     * @return Firma k-minHash come vettore di interi.
     */
    std::vector<uint64_t> computeSignature(std::vector<uint64_t> s);
};#include "HashFunction.h"
#include <vector>

class OnePermutation {
private:
    size_t k;  ///< Numero di bins.
    size_t m;  ///< Modulo per le funzioni hash.
    HashFunction* funzHash; ///< Funzioni hash.

public:
    /**
     * Costruttore.
     * @param k: Numero di funzioni hash.
     * @param m: Modulo per le funzioni hash.
     * @param seed: Semina per il generatore casuale.
     */
    OnePermutation(size_t k, size_t m, size_t seed);

    /**
     * Calcola la firma k-minHash di un vettore.
     * @param s: Vettore di input.
     * @return Firma k-minHash come vettore di interi.
     */
    std::vector<uint64_t> computeSignature(std::vector<uint64_t> s);
};#include <iostream>
#include <vector>
#include <algorithm>
// #include "KMinHash.h"
#include "OnePermutation.h"
// #include "FastSimilaritySketching.h"
#include <fstream>
#include <sstream>

/**
 * Calcola la Jaccard Similarity esatta tra due insiemi (Algoritmo Naive).
 * @param set1: Primo insieme.
 * @param set2: Secondo insieme.
 * @return Similarità di Jaccard.
 */
float jsEsatta(std::vector<uint64_t> set1, std::vector<uint64_t> set2) {
    std::vector<uint64_t> unione, intersezione;
    size_t lenS1 = set1.size(), lenS2 = set2.size();
    unione = set1;
    for (size_t i = 0; i < lenS2; i++){
        if (std::find(unione.begin(), unione.end(), set2[i]) == unione.end()){
            unione.push_back(set2[i]);
        }
    }
    for (size_t i = 0; i < lenS1; i++){
        if (std::find(set2.begin(), set2.end(), set1[i]) != set2.end()){
            intersezione.push_back(set1[i]);
        }
    }
    float js = static_cast<float>(intersezione.size()) / unione.size();
    return js;
}

/**
 * Funzione per il calcolo della Jaccard Similarity Approssimata
 * @param s1: firme del prima insieme 
 * @param s2: firme del secondo insieme
 * @param k: lunghezza dei vettori delle firme (numero delle funzioni hash utilizzate)
 * @return Similarità di Jaccard Aprrossimata.
 */
float jsApprossimata(std::vector<uint64_t> s1, std::vector<uint64_t> s2, int k){
    size_t count = 0;
    for (size_t i = 0; i < k; i++){
        if (s1[i] == s2[i]){
            count++;
        }
    }
    return static_cast<float>(count)/k;
}

/**
 * Funzione di utilità per stampare un vettore.
 * @param array: Vettore da stampare.
 */
void printVector(const std::vector<uint64_t>& vettore) {
    std::cout << "[ ";
    for (size_t val : vettore) {
        std::cout << val << " ";
    }
    std::cout << "]" << std::endl;
}

void leggiFile(std::string&filename,std::vector<std::pair<std::vector<uint64_t>, std::vector<uint64_t>>>& coppie){
    std::ifstream inFile(filename); // per aprire il file
    std::string line; // per memorizzare ogni riga del file durante la lettura
    while (std::getline(inFile, line)) {  
        std::vector<uint64_t> set1, set2;
        std::istringstream s1(line); // inizializza un flusso di input dalla stringa line
        size_t num;
        while (s1>>num){
            set1.push_back(num);
        }
        if (!std::getline(inFile, line)) break;
        std::istringstream s2(line);
        while (s2 >> num) {
            set2.push_back(num); 
        }
        std::getline(inFile, line);
        
        coppie.push_back({set1, set2});

        std::getline(inFile, line);
        }
}


int main(int argc, char* argv[]) {
    if (argc < 3) {
        std::cerr << "Utilizzo: " << argv[0] << " <k> <dimensione_m>\n";
        return 1;
    }
    size_t k = std::stoi(argv[1]); // Numero di funzioni hash
    size_t m = std::stoi(argv[2]); // Modulo dell'universo
    size_t seed = 2; // Seed fisso per test ripetibili

    std::string filename ="dataset_0.47.txt";
    std::vector<std::pair<std::vector<uint64_t>, std::vector<uint64_t>>> coppie;
    leggiFile(filename, coppie);
    for (auto& coppia:coppie){
        std::vector<uint64_t> set1 = coppia.first;
        std::vector<uint64_t> set2 = coppia.second;
        
        // Vettori di input
        // std::vector<uint64_t> set1 = {1, 6, 7, 14, 3, 10, 11};
        //std::vector<uint64_t> set2 = {1, 2, 6, 7, 16, 11, 4, 9, 3};

        std::cout << "Set_1: ";
        printVector(set1);
        std::cout << "Set_2:";
        printVector(set2);
    /*
        // Calcolo k-minHash
        KMinHash kMinHash(k, m, seed);
        std::vector<uint64_t> firma1 = kMinHash.computeSignature(set1);
        std::vector<uint64_t> firma2 = kMinHash.computeSignature(set2);
    */ 
    
      // Calcolo OnePerm
        OnePermutation oph(k,m,seed);
        std::vector<uint64_t> firma1 = oph.computeSignature(set1);
        std::vector<uint64_t> firma2 = oph.computeSignature(set2);

        // Calcolo FastSimilaritySketching
        //FastSimilaritySketching fss(k, m, seed);
        //std::vector<double> firma1 = fss.computeSignature(set1);
        //std::vector<double> firma2 = fss.computeSignature(set2);

        // std::cout << "Firma Set_1: ";
        // printVector(firma1);
        // std::cout << "Firma Set_2: ";
        // printVector(firma2);

        // Calcolo della Jaccard Similarity approssimata
        float approxJaccard = jsApprossimata(firma1, firma2, k);
        std::cout << "Approximate Jaccard Similarity: " << approxJaccard << "\n";

        // Calcolo della Jaccard Similarity esatta
        float exactJaccard = jsEsatta(set1, set2);
        std::cout << "Exact Jaccard Similarity: " << exactJaccard << "\n";

        std::cout << "\n";
    
    }

    return 0;
}